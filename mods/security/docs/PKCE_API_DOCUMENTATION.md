# XyPriss Security - PKCE (RFC 7636) Implementation Guide

## Overview

The `Cipher.hash.pkce()` method provides **RFC 7636 compliant** Proof Key for Code Exchange (PKCE) functionality for OAuth 2.0 authentication flows. This implementation ensures compatibility with mobile applications (such as React Native with expo-crypto) and desktop applications.

## Problem Solved

Previously, `Cipher.hash.create()` produced hex-encoded hashes that were **not compatible** with the PKCE specification, causing authentication failures in cross-platform OAuth 2.0 implementations.

## Quick Start

```typescript
import { Cipher } from "xypriss-security";

// Generate PKCE code challenge from verifier
const codeVerifier = "uCoEh3q6tUR0_eVlsr6b6qjfzeWf_jnfoif8XQvTPeMq~zG6MyiEyhAroiJrmcrCb8JNqd6tSqvYX~1nLcD29.QU~iIxeGZleMeiiC1vfd.hLns0MuQZuTL.NqByFF0K";
const codeChallenge = Cipher.hash.pkce(codeVerifier);

console.log(codeChallenge); // "eHjZE0STxWg9BRtooH5xl3J5SZ__EUUvjv_UQZXgUII"
```

## API Reference

### `Cipher.hash.pkce(codeVerifier, method?)`

Generates a PKCE code challenge from a code verifier according to RFC 7636.

#### Parameters

- **`codeVerifier`** (string, required): The code verifier string generated by your application
- **`method`** (string, optional): The challenge method. Defaults to `'S256'`
  - `'S256'`: SHA256 with Base64URL encoding (recommended)
  - `'plain'`: Plain text (less secure, not recommended)

#### Returns

- **string**: The PKCE code challenge in Base64URL format (for S256) or plain text (for plain method)

#### Examples

```typescript
// S256 method (default and recommended)
const challenge = Cipher.hash.pkce(codeVerifier);
// Returns: "eHjZE0STxWg9BRtooH5xl3J5SZ__EUUvjv_UQZXgUII"

// Explicit S256 method
const challenge = Cipher.hash.pkce(codeVerifier, 'S256');

// Plain method (not recommended for production)
const challenge = Cipher.hash.pkce(codeVerifier, 'plain');
// Returns: the same codeVerifier string
```

## OAuth 2.0 Integration

### Complete PKCE Flow Example

```typescript
import { Cipher } from "xypriss-security";
import * as crypto from "crypto";

// Step 1: Generate code verifier (client-side)
function generateCodeVerifier(): string {
  // Generate a cryptographically secure random string
  return crypto.randomBytes(32).toString('base64url');
}

// Step 2: Generate code challenge (client-side)
function generateCodeChallenge(codeVerifier: string): string {
  return Cipher.hash.pkce(codeVerifier);
}

// Step 3: OAuth authorization request
const codeVerifier = generateCodeVerifier();
const codeChallenge = generateCodeChallenge(codeVerifier);

const authUrl = new URL('https://auth.example.com/authorize');
authUrl.searchParams.set('code_challenge', codeChallenge);
authUrl.searchParams.set('code_challenge_method', 'S256');
authUrl.searchParams.set('client_id', 'your-client-id');
authUrl.searchParams.set('redirect_uri', 'your-redirect-uri');

// Step 4: Token exchange (server-side)
async function exchangeCodeForToken(authorizationCode: string, codeVerifier: string) {
  // Verify the code challenge matches before sending to auth server
  const expectedChallenge = Cipher.hash.pkce(codeVerifier);

  // Make token request with code_verifier
  const tokenResponse = await fetch('https://auth.example.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: authorizationCode,
      code_verifier: codeVerifier,
      client_id: 'your-client-id',
      redirect_uri: 'your-redirect-uri'
    })
  });

  return tokenResponse.json();
}
```

### React Native / Expo Integration

```typescript
import { Cipher } from "xypriss-security";
import * as Crypto from 'expo-crypto';

// Mobile applications can now use consistent PKCE implementation
const codeVerifier = generateRandomString(128); // Your random generation
const codeChallenge = Cipher.hash.pkce(codeVerifier); // Matches expo-crypto output

// This will now work seamlessly with backend validation
const backendChallenge = await fetch('/api/oauth/challenge', {
  method: 'POST',
  body: JSON.stringify({ codeVerifier }),
  headers: { 'Content-Type': 'application/json' }
});
```

## Migration from Legacy Implementation

### Before (Broken)

```typescript
// ❌ This produced hex output, not RFC 7636 compliant
const challenge = Cipher.hash.create(codeVerifier);
// Result: "7878d9134493c5683d051b68a07e71977279499fff11452f8effd44195e05082"
```

### After (Fixed)

```typescript
// ✅ RFC 7636 compliant, matches mobile implementations
const challenge = Cipher.hash.pkce(codeVerifier);
// Result: "eHjZE0STxWg9BRtooH5xl3J5SZ__EUUvjv_UQZXgUII"
```

### Migration Script

```typescript
// For existing applications, replace:
const challenge = Cipher.hash.create(codeVerifier);

// With:
const challenge = Cipher.hash.pkce(codeVerifier);

// No other changes needed - same API, correct output format
```

## Security Considerations

### ✅ Secure by Default

- **SHA256**: Uses cryptographically secure SHA256 hashing
- **Base64URL**: RFC 7636 compliant encoding format
- **Deterministic**: Same input always produces same output
- **No Random Salt**: PKCE requires deterministic challenges

### ⚠️ Important Notes

1. **Code Verifier Requirements**: Must be 43-128 characters, URL-safe
2. **Method Consistency**: Use same method on client and server
3. **Timing Safety**: Method is designed to be timing-safe
4. **No Pepper Support**: PKCE doesn't use peppers (specification requirement)

### Code Verifier Generation

```typescript
import * as crypto from "crypto";

// Generate RFC 7636 compliant code verifier
function generateCodeVerifier(length: number = 128): string {
  const randomBytes = crypto.randomBytes(length);
  return randomBytes.toString('base64url')
    .replace(/[^A-Za-z0-9\-_.]/g, '') // Remove invalid chars
    .substring(0, length); // Ensure exact length
}

// Example usage
const verifier = generateCodeVerifier(128);
const challenge = Cipher.hash.pkce(verifier);
```

## Testing

### Manual Verification

```typescript
import { Cipher } from "xypriss-security";
import * as crypto from "crypto";

// Test against known values
const testVerifier = "uCoEh3q6tUR0_eVlsr6b6qjfzeWf_jnfoif8XQvTPeMq~zG6MyiEyhAroiJrmcrCb8JNqd6tSqvYX~1nLcD29.QU~iIxeGZleMeiiC1vfd.hLns0MuQZuTL.NqByFF0K";
const expectedChallenge = "eHjZE0STxWg9BRtooH5xl3J5SZ__EUUvjv_UQZXgUII";

const actualChallenge = Cipher.hash.pkce(testVerifier);
console.log("Test passed:", actualChallenge === expectedChallenge);
```

### Cross-Platform Testing

```typescript
// This method produces identical output across:
// - Node.js (backend)
// - React Native with expo-crypto
// - Web browsers
// - Mobile applications

const challenge = Cipher.hash.pkce(codeVerifier);
// Always produces the same Base64URL-encoded challenge
```

## Error Handling

```typescript
try {
  const challenge = Cipher.hash.pkce(codeVerifier);
  // Use challenge in OAuth flow
} catch (error) {
  // Handle errors (e.g., invalid input format)
  console.error("PKCE generation failed:", error.message);
}
```

## Performance

- **Fast**: Single SHA256 operation
- **Memory Efficient**: No unnecessary buffering
- **Optimized**: Minimal computational overhead
- **Scalable**: Handles high-frequency OAuth requests

## References

- [RFC 7636: Proof Key for Code Exchange (PKCE)](https://tools.ietf.org/html/rfc7636)
- [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)
- [PKCE Implementation Guide](https://oauth.net/2/pkce/)

## Support

For issues or questions about the PKCE implementation:

- Check the [XyPriss Security documentation](https://lab.nehonix.space/nehonix_viewer/_doc/Nehonix%20xypriss/readme.md)
- Report bugs on [GitHub Issues](https://github.com/Nehonix-Team/XyPriss/issues)
- Join the [community discussions](https://github.com/Nehonix-Team/XyPriss/discussions)
